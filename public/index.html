<!DOCTYPE html>
<meta charset="utf-8">
<html lang="en">

<head>
<link rel="icon" href="images/favicon.png">
<title>Bi-Plane Paint Duel!</title>
</head>

<body>
<script src="./pixi/pixi.min.js"></script>
<script>
  //Aliases
  let Application = PIXI.Application,
      Container = PIXI.Container,
      loader = PIXI.loader,
      resources = PIXI.loader.resources,
      Graphics = PIXI.Graphics,
      TextureCache = PIXI.utils.TextureCache,
      Sprite = PIXI.Sprite,
      Text = PIXI.Text,
      TextStyle = PIXI.TextStyle;

  //Create app
  let app = new Application(
    {
      width: 2102, 
      height: 796,                       
      antialiasing: true, 
      transparent: false, 
      resolution: 1
    }
  );

  //Add the canvas
  document.body.appendChild(app.view);
  loader
    .add("images/bi-paint-textures.json").load(setup);

  let state, rafPlane, redBaron, plane, paintBall, animPaintBalls, crash, airCollision, checkPlaneShot, animPaintedPlane, homeFlight, balloon, gameScene, gameOverScene, id, sky, largeCloud1, largeCloud2, flatCloud, flatCloudDistant, hills, nearHill, hut, rafPaintBall, redBaronPaintBall, keyState, p1, p2, airCrashedRAF, airCrashedRB, airColAnim;
  
  function setup() {
    gameScene = new Container();
    app.stage.addChild(gameScene);
    id = resources["images/bi-paint-textures.json"].textures;
  
    // set up assets
    sky = new Sprite(id["Backgrd.png"]);
    gameScene.addChild(sky);

    balloon = new Sprite(id["Balloon.png"]);
    balloon.x = 850;
    balloon.y = 550;
  
    largeCloud1 = new Sprite(id["BIGCloud.png"]);
    largeCloud1.x = 600;
    largeCloud1.y = 220;
  
    largeCloud2 = new Sprite(id["BIGCloud.png"]);
    largeCloud2.x = 260;
    largeCloud2.y = 180;
  
    hills = new Sprite(id["Hills.png"]);
    hills.y = 796 - hills.height;
  
    nearHill = new Sprite(id["Front_Hill.png"]);
    nearHill.y = sky.height - nearHill.height;
  
    hut = new Sprite(id["House.png"]);
    hut.x = sky.width/2 - hut.width/2;
    hut.y = sky.height - hut.height;

    // set up rafPlane
    rafPlane = new Sprite(id["RAF_Plane02sized.png"]);
    plane(rafPlane, 122);

    // red Baron
    redBaron = new Sprite(id["RedBarren flipped.png"]);
    plane(redBaron, sky.width - redBaron.width - 42);
    
    // set up key logging
    keyState = [];
  
    flatCloud = new Sprite(id["FlatCloud.png"]);
    flatCloud.x = 160;
    flatCloud.y = 600;
  
    flatCloudDistant = new Sprite(id["FlatCloud_distant.png"]);
    flatCloudDistant.x = 800;
    flatCloudDistant.y = 580;

    // players
    p1 = {score: 0, shots: []};
    p2 = {score: 0, shots: []};

    gameScene.addChild(flatCloudDistant, hills, flatCloud, nearHill, balloon, hut, rafPlane, redBaron, largeCloud1, largeCloud2);

    //Set the game state
    state = play;
  
    //Start the game loop 
    app.ticker.add(delta => gameLoop(delta));
  }
  
  function gameLoop(delta) {
    state(delta);
  }
  
  function play() {
    // left, right and sky boundary
    if (rafPlane.x > sky.width - 40) rafPlane.x = 0;
    if (rafPlane.x < 0) rafPlane.x = sky.width - 40;
    if (rafPlane.y < 28) {
      rafPlane.y = 28; 
      rafPlane.stall = true;
    }
    if (redBaron.x > sky.width - 40) redBaron.x = 0;
    if (redBaron.x < 0) redBaron.x = sky.width - 40;
    if (redBaron.y < 28) {
      redBaron.y = 28; 
      redBaron.stall = true;
    }

    if (airColAnim) {
      if (airCrashedRAF.y < sky.height - 20) airCrashedRAF.y += 5;
      if (airCrashedRB.y < sky.height - 20) airCrashedRB.y += 5;
    }

    // air collision, 2x rectangles
    if (
      !(rafPlane.x + rafPlane.width < redBaron.x) &&
      !(redBaron.x + redBaron.width < rafPlane.x) &&
      !(rafPlane.y + rafPlane.height < redBaron.y) &&
      !(redBaron.y + redBaron.height < rafPlane.y)
      ) {
      airColAnim = true;
      p1.score += 1;
      p2.score += 1;

      airCrashedRAF = new Sprite(id["crashedRAF.png"]);
      airCrashedRB = new Sprite(id["crashedRB.png"]);
      airCollision(rafPlane, redBaron, airCrashedRAF, airCrashedRB);

      rafPlane = new Sprite(id["RAF_Plane02sized.png"]);
      plane(rafPlane, 122);
      gameScene.addChild(rafPlane);

      redBaron = new Sprite(id["RedBarren flipped.png"]);
      plane(redBaron, sky.width - redBaron.width - 42);
      gameScene.addChild(redBaron);
    }

    // rafPlane collision logic
    let rafGrCol = false, hutWallCol = false, hutRoofCol = false;
    // ground col
    if (rafPlane.takeOff && rafPlane.y > sky.height - 28) rafGrCol = true;

    // hut wall col, 2x rectangles
    if (
      !(hut.x + hut.width < rafPlane.x + 20) &&
      !(rafPlane.x + rafPlane.width < hut.x + 50) &&
      !(hut.y + hut.height < rafPlane.y) &&
      !(rafPlane.y + rafPlane.height < hut.y + 88)
    ) hutWallCol = true;

    // hut roof col, hut roof roughly circular 2x circles
    hutRoofCol = (() => {
      let dX = hut.x + 75 - rafPlane.x, dY = hut.y + 70 - rafPlane.y;
      let distance = Math.sqrt( (dX * dX ) + (dY * dY ) );
      return distance < ( ((hut.width - 20) / 2) + (rafPlane.height / 2 ) );
    })();

    // rafPlane ground or hut collision occurred
    if (rafGrCol || hutWallCol || hutRoofCol) {
      p2.score += 1;
      crashedPlane = new Sprite(id["crashedRAF.png"]);
      crash(rafPlane, crashedPlane);
      rafPlane = new Sprite(id["RAF_Plane02sized.png"]);
      plane(rafPlane, 122);
      gameScene.addChild(rafPlane);
    }
    
    // redBaron collision logic
    let RBGrCol = false, RBhutWallCol = false, RBhutRoofCol = false;
    // ground coll
    if (redBaron.takeOff && redBaron.y > sky.height - 28) RBGrCol = true;

    // hut wall coll, 2x rectangles
    if (
      !(hut.x + hut.width < redBaron.x + 20) &&
      !(redBaron.x + redBaron.width < hut.x + 50) &&
      !(hut.y + hut.height < redBaron.y) &&
      !(redBaron.y + redBaron.height < hut.y + 88)
    ) RBhutWallCol = true;

    // hut roof coll, 2x circles
    RBhutRoofCol = (() => {
      let dX = hut.x + 75 - redBaron.x, dY = hut.y + 70 - redBaron.y;
      let distance = Math.sqrt( (dX * dX ) + (dY * dY ) );
      return distance < ( ((hut.width - 20) / 2) + (redBaron.height / 2 ) );
    })();

    // redBaron ground or hut collision occured
    if (RBGrCol || RBhutWallCol || RBhutRoofCol) {
      p1.score += 1;
      crashedPlane = new Sprite(id["crashedRB.png"]);
      crash(redBaron, crashedPlane);
      redBaron = new Sprite(id["RedBarren flipped.png"]);
      plane(redBaron, sky.width - redBaron.width - 42);
      gameScene.addChild(redBaron);
    }

    // left and right controls
    if (rafPlane.takeOff) {
      //z key
      if(keyState[90]) {
        rafPlane.rotation -= 1/8;
        if (rafPlane.rotation < (-2 * Math.PI)) {
          rafPlane.rotation = 0;
        }
      }
      //x key
      if(keyState[88]) {
        rafPlane.rotation += 1/8;
        if (rafPlane.rotation > 2 * Math.PI) {
          rafPlane.rotation = 0;
        }
      }
    }

    if (redBaron.takeOff) {
      //Left arrow key
      if(keyState[37]) {
        redBaron.rotation -= 1/8;
        if (redBaron.rotation < (-2 * Math.PI)) {
          redBaron.rotation = 0;
        }
      };
      // right arrow
      if(keyState[39]) {
        redBaron.rotation += 1/8;
        if (redBaron.rotation > 2 * Math.PI) {
          redBaron.rotation = 0;
        }
      }
    }

    // rafPlane regular flight
    if (!rafPlane.stall) {
      // gravity
      // plane flying up
       if ( (rafPlane.rotation < 0 && rafPlane.rotation > -Math.PI)  || (rafPlane.rotation > Math.PI && rafPlane.rotation < 2 * Math.PI) ) {
      rafPlane.speed -= 0.25 * Math.abs(Math.sin(rafPlane.rotation));
      }
      // plane flying down
      if (rafPlane.speed < 10 && ((-Math.PI > rafPlane.rotation && rafPlane.rotation > -2 * Math.PI) || (rafPlane.rotation > 0 && rafPlane.rotation < Math.PI))) {
        rafPlane.speed += 0.25 * Math.abs(Math.sin(rafPlane.rotation));
      }

      // wind resistance
      if (rafPlane.speed > 2) {
        rafPlane.speed -= 0.02;
      }

      rafPlane.vx = rafPlane.speed * Math.cos(rafPlane.rotation);
      rafPlane.vy = rafPlane.speed * Math.sin(rafPlane.rotation);
      // correct plane snaps horizontally to 3.125 instead of Pi
      if (rafPlane.vy < 0 && rafPlane.vy > -0.25) rafPlane.vy = 0;
      rafPlane.x += rafPlane.vx;
      rafPlane.y += rafPlane.vy;

      // plane able to take off begin mechanics
      if (rafPlane.speed > 5) {
        rafPlane.takeOff = true;
      }

      // slow plane loss of uplift
      if (rafPlane.takeOff && rafPlane.speed < 5) {
        rafPlane.y += 1;
      }

      // accelerate, q
      if(keyState[65]) {
        if (rafPlane.speed < 6) {
          rafPlane.speed += 0.16;
        }
      }

      if (rafPlane.takeOff && rafPlane.speed < 3) {
        rafPlane.stall = true;
        keyState[65] = false;
      }
    }

    // rafPlane if stalled
    if (rafPlane.takeOff && rafPlane.stall) {
      // if stalling facing left continue fall left
      if ((rafPlane.rotation < -0.5 * Math.PI && rafPlane.rotation > -1.5 * Math.PI) || (rafPlane.rotation > 0.5 * Math.PI && rafPlane.rotation < 1.5 * Math.PI)) {
        rafPlane.x -= 1;
      }
      // if stalling facing right, fall right
      if ((rafPlane.rotation > -0.5 * Math.PI && rafPlane.rotation < 0) || (rafPlane.rotation > 1.5 * Math.PI && rafPlane.rotation < 2 * Math.PI)) {
        rafPlane.x += 1;
      }
      // gravity
      rafPlane.y *= 1.0125;

      // if facing downward no stall
      if ((rafPlane.rotation < -1.4 * Math.PI && rafPlane.rotation > -1.6 * Math.PI) || (rafPlane.rotation > 0.4 * Math.PI && rafPlane.rotation < 0.6 * Math.PI)) {
        rafPlane.speed = 4;
        rafPlane.stall = false;
        keyState[65] = true;
      }
    }

    // redBaron regular flight
    if (!redBaron.stall) {
      // gravity
      // plane elevation up
      if ( (redBaron.rotation > 0 && redBaron.rotation < Math.PI)  || (redBaron.rotation < -Math.PI && redBaron.rotation > -2 * Math.PI) ) {
      redBaron.speed -= 0.25 * Math.abs(Math.sin(redBaron.rotation));
      }
      // plane elevation down
      if (redBaron.speed < 10 && ((redBaron.rotation < 0 && redBaron.rotation > -Math.PI)  || (redBaron.rotation > Math.PI && redBaron.rotation < 2 * Math.PI))) {
        redBaron.speed += 0.25 * Math.abs(Math.sin(redBaron.rotation));
      }

      // wind resistance
      if (redBaron.speed > 2) {
        redBaron.speed -= 0.02;
      }

      redBaron.vx = redBaron.speed * Math.cos(redBaron.rotation);
      redBaron.vy = redBaron.speed * Math.sin(redBaron.rotation);
      // correct plane 'snaps' horizontally to 3.125 instead of Pi
      if (redBaron.vy > 0 && redBaron.vy < 0.25) redBaron.vy = 0;
      redBaron.x -= redBaron.vx;
      redBaron.y -= redBaron.vy;

      // plane able to take off begin mechanics
      if (redBaron.speed > 5) {
        redBaron.takeOff = true;
      }

      // slow plane loss of uplift
      if (redBaron.takeOff && redBaron.speed < 5) {
        redBaron.y += 1;
      }

      // accelerate, up arrow
      if(keyState[38]) {
        if (redBaron.speed < 6) {
          redBaron.speed += 0.16;
        }
      }

      if (redBaron.takeOff && redBaron.speed < 3) {
        redBaron.stall = true;
        keyState[38] = false;
      }
    }

    // redBaron if stalled
    if (redBaron.takeOff && redBaron.stall) {
      // if stalling facing left continue fall left
      if ((redBaron.rotation < 0.5 * Math.PI && redBaron.rotation > -0.5 * Math.PI) || (redBaron.rotation > 1.5 * Math.PI && redBaron.rotation < -1.5 * Math.PI)) {
        redBaron.x -= 1;
      }
      // if stalling facing right, fall right
      if ((redBaron.rotation > 0.5 * Math.PI && redBaron.rotation < 1.5 * Math.PI) || (redBaron.rotation < -0.5 * Math.PI && redBaron.rotation < -1.5 * Math.PI)) {
        redBaron.x += 1;
      }
      // gravity
      redBaron.y *= 1.0125;

      // if facing downward no stall
      if ((redBaron.rotation < -0.4 * Math.PI && redBaron.rotation > -0.6 * Math.PI) || (redBaron.rotation > 1.4 * Math.PI && redBaron.rotation < 1.6 * Math.PI)) {
        redBaron.speed = 4;
        redBaron.stall = false;
        keyState[38] = true;
      }
    }

    // rafPlane fire paintball
    if(rafPlane.takeOff && p1.shots.length < 2) {
      if (keyState[83]) {
        keyState[83] = false;
        let shot = (new Sprite(id["rafPaintBall.png"]));
        p1.shots[p1.shots.length] = shot;
        paintBall(rafPlane, shot);
      }
    }

    // redBaron fire paintball
    if(redBaron.takeOff && p2.shots.length < 2) {
      if (keyState[80]) {
        keyState[80] = false;
        let shot = (new Sprite(id["RBPaintBall.png"]));
        p2.shots[p2.shots.length] = shot;
        paintBall(redBaron, shot);
      }
    }

    if (p1.shots.length > 0) {
      animPaintBalls(p1);
      checkPlaneShot(redBaron, p1);
    }

    if (p2.shots.length > 0) {
      animPaintBalls(p2);
      checkPlaneShot(rafPlane, p2);
    }

    checkPlaneShot = function checkPlaneShot(shotPlane, attackingPlayer) {
      // circle (shot) colliding with rectangle (plane)
      function rectCircleColl(circle, rect) {
        let distX = Math.abs( (circle.x - rect.x - (rect.width / 2)) + 40);
        let distY = Math.abs( (circle.y - rect.y - (rect.height / 2)) + 29);
        if (distX > (rect.width/ 2 + circle.width / 2)) return false;
        if (distY > (rect.height/ 2 + circle.width / 2)) return false;
        if (distX <= (rect.width / 2)) return true;
        if (distY <= (rect.height / 2)) return true;
        let dx = distX - rect.width / 2;
        let dy = distY - rect.width / 2;
        return (dx * dx + dy * dy <= (circle.width/ 2 * circle.width / 2));
      }
      for (let i = 0; i < attackingPlayer.shots.length; i++) {
        if (rectCircleColl(attackingPlayer.shots[i], shotPlane)) {
          attackingPlayer.score += 1;
          // if (attackingPlayer.score > 15) {}
          gameScene.removeChild(attackingPlayer.shots[i]);
          attackingPlayer.shots.splice(i, 1);
          shotPlane.painted = true;
          animPaintedPlane(shotPlane);
          break;
        }
      }
    }

    // change sprite to painted version, set home flight auto pilot coords
    animPaintedPlane = function animPaintedPlane(shotPlane) {
      let painted, player;
      (shotPlane === rafPlane) ? (painted = new Sprite(id["RAFPainted.png"]), player = p1) : (painted = new Sprite(id["RBPainted.png"]), player = p2);
      painted.x = shotPlane.x;
      painted.y = shotPlane.y;
      painted.rotation = shotPlane.rotation;
      painted.pivot.x = shotPlane.pivot._x;
      painted.pivot.y = shotPlane.pivot._y;
      player.painted = painted;
      // build auto-pilot flight coords to home
      (function buildFlightPath() {
        let homeX = (player === p1) ? 40 : sky.width - 43, homeY = sky.height - 30;
        if (player === p1) {
          // facing away from home, continue same direction for screen wrap effect
          if (-0.5 * Math.PI < p1.painted.rotation && p1.painted.rotation < 0.5 * Math.PI) {
            // low plane left of screen would appear to hit the hut if flying home
            if (p1.painted.y < sky.height - 200) {
              if (p1.painted.x < sky.width / 2) {
                p1.painted.flightCoords = [ [homeX, homeY], [0, homeY], [sky.width, sky.height], [sky.width / 2, 500] ];
              } else {
                p1.painted.flightCoords = [ [homeX, homeY], [sky.width, sky.height], [0, homeY] ];
              }
            } else {// normal height, regular flight path
              p1.painted.flightCoords = [ [ homeX, homeY], [sky-width - 400 , sky.height - 300], [sky-width - 375, sky.height - 275], [sky-width - 350, sky.height - 250], [sky-width - 325, sky.height - 225], [sky-width - 300, sky.height - 200], [sky-width - 275, sky.height - 175], [sky-width - 250, sky.height - 150], [sky-width - 225, sky.height - 125], [sky-width - 200, sky.height - 100], [sky-width - 175, sky.height - 75 ], [sky-width - 100, sky.height - 50], [sky-width - 50, sky.height - 50], [sky-width - 25, sky.height - 40], [0, homeY] ];
            }
          } else {// facing towards home, fly directly
            if (p1.painted.y < sky.height - 200) {
              if (p1.painted.x > sky.width / 2) {
                p1.painted.flightCoords = [ [homeX, homeY], [sky.width / 2, 500] ];
              } else {
                p1.painted.flightCoords = [ [homeX, homeY] ];
              }
            }
          }
        } else {// p2
          if (-0.5 * Math.PI < p2.painted.rotation && p2.painted.rotation < 0.5 * Math.PI) {
            if (p2.painted.y < sky.height - 200) {
              if (p2.painted.x > sky.width / 2) {
                p2.painted.flightCoords = [ [homeX, homeY], [0, homeY], [sky.width, homeY],   [sky.width / 2, 500] ];
              } else {
                p2.painted.flightCoords = [ [homeX, homeY], [0, homeY], [sky.width, homeY] ];
              }
            } else {// normal height, regular flight path
              p2.painted.flightCoords = [ [ homeX, homeY], [sky.width, homeY], [0, sky.height - 35], [25, sky.height - 40], [50, sky.height - 50], [125, sky.height - 50], [175, sky.height - 75 ], [200, sky.height - 100], [225, sky.height - 125], [250, sky.height - 150], [275, sky.height - 175], [300, sky.height - 200], [325, sky.height - 225], [350, sky.height - 250], [375, sky.height - 275], [400, sky.height - 300] ];
            }
          } else {// facing towards home, fly directly
            if (p2.painted.y < sky.height - 200) {
              if (p2.painted.x < sky.width / 2) {
                p2.painted.flightCoords = [ [homeX, homeY], [sky.width / 2, 500] ];
              } else {
                p2.painted.flightCoords = [ [homeX, homeY] ];
              }
            }
          }
        }      
      })();
      gameScene.removeChild(shotPlane);
      gameScene.addChild(player.painted);
    }

    if (p1.painted !== undefined) {
      homeFlight(p1);
    }

    if (p2.painted !== undefined) {
      homeFlight(p2);
    }

    // painted, auto flight home
    homeFlight = function homeFlight(player) {
      
      // hard coded test end points working!  
      // todo: complete function to auto fly through all coords in provided array 

      player.painted.x = player.painted.flightCoords[0][0];
      player.painted.y = player.painted.flightCoords[0][1];
    }

  }

  
  /* Helper functions */
  // set up planes
  plane = function plane(planeSprite, x) {
    planeSprite.x = x;
    planeSprite.y = sky.height - planeSprite.height/2;
    planeSprite.rotation = 0;
    planeSprite.speed = 0;
    planeSprite.pivot._x = 40;
    planeSprite.pivot._y = 28;
    planeSprite.takeOff = false;
    planeSprite.stall = false;
    return null;
  }

  // Fire paint ball
  paintBall = function paintBall(plane, shot) {
    shot.x = plane.x;
    shot.y = plane.y;
    shot.rotation = plane.rotation;
    shot.speed = 15;
    if (plane === rafPlane) {
      shot.pivot._x = -28;
      shot.pivot._y = 10;
    } else {
      shot.pivot._x = 45;
      shot.pivot._y = 10;
    }
    gameScene.addChild(shot);
  }

  // animate paint balls
  animPaintBalls = function animPaintBalls(player) {
    for (let i = 0; i < player.shots.length; i++) {
      let vx = player.shots[i].speed * Math.cos(player.shots[i].rotation);
      let vy = player.shots[i].speed * Math.sin(player.shots[i].rotation);
      // correct rotation snaps horizontally to 3.125 instead of Pi
      if ( (vy < 0.25 && vy > 0) || (vy < 0 && vy > -0.25)  )  vy = 0;

      if (player === p1) {
        player.shots[i].x += vx;
        player.shots[i].y += vy;
      } else {
        player.shots[i].x -= vx;
        player.shots[i].y -= vy;
      }

      // shot boundaries
      if (player.shots[i].x > sky.width - 35 || player.shots[i].x < 0 || player.shots[i].y < 0 || player.shots[i].y > sky.height) {
        gameScene.removeChild(player.shots[i]);
        player.shots.splice(player.shots[i], 1);
      }
    }
  }

  // func to swap in crashed plane sprite
  crash = function crash(planeSprite, crashedPlane) {
    crashedPlane.x = planeSprite.x;
    crashedPlane.y = planeSprite.y;
    crashedPlane.pivot._x = planeSprite.pivot._x;
    crashedPlane.pivot._y = planeSprite.pivot._y;
    crashedPlane.rotation = planeSprite.rotation;
    gameScene.addChild(crashedPlane);
    gameScene.removeChild(planeSprite);
    setTimeout(() => {gameScene.removeChild(crashedPlane)}, 1400);
  }

  // mid air collision
  airCollision = function airCollision(raf, rB, crashedRAF, crashedRB) {
    crashedRAF.x = raf.x;
    crashedRAF.y = raf.y;
    crashedRAF.pivot._x = raf.pivot._x;
    crashedRAF.pivot._y = raf.pivot._y;
    crashedRAF.rotation = raf.rotation;

    gameScene.addChild(crashedRAF);
    gameScene.removeChild(raf);
    setTimeout(() => {gameScene.removeChild(crashedRAF); 
      airColAnim = false}, 1400);

    crashedRB.x = rB.x;
    crashedRB.y = rB.y;
    crashedRB.pivot._x = rB.pivot._x;
    crashedRB.pivot._y = rB.pivot._y;
    crashedRB.rotation = rB.rotation;
    gameScene.addChild(crashedRB);
    gameScene.removeChild(rB);
    setTimeout(() => {
      gameScene.removeChild(crashedRB);
      airColAnim = false;
    }, 1400);
  }

  // key log funcs
  const keyPress = function(e) {
    if (e.keyCode === 38 || e.keyCode === 37 || e.keyCode === 39 || e.keyCode === 80 || e.keyCode === 65 || e.keyCode === 88 || e.keyCode === 83 || e.keyCode === 90) {
      keyState[e.keyCode] = true;
      event.preventDefault();
    }
  }

  const keyRelease = function(e) {
    if (e.keyCode === 38 || e.keyCode === 37 || e.keyCode === 39 || e.keyCode === 80 || e.keyCode === 65 || e.keyCode === 88 || e.keyCode === 83 || e.keyCode === 90) {
      keyState[e.keyCode] = false;
      event.preventDefault();
    }
  }

  window.addEventListener("keydown", keyPress);
  window.addEventListener("keyup", keyRelease);

  </script>
</script>
</body>
</html>