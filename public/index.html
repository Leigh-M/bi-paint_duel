<!DOCTYPE html>
<meta charset="utf-8">
<html lang="en">

<head>
<link rel="icon" href="images/favicon.png">
<title>Bi-Plane Paint Duel!</title>
</head>

<body>
<script src="./pixi/pixi.min.js"></script>
<script>
  //Aliases
  let Application = PIXI.Application,
      Container = PIXI.Container,
      loader = PIXI.loader,
      resources = PIXI.loader.resources,
      Graphics = PIXI.Graphics,
      TextureCache = PIXI.utils.TextureCache,
      Sprite = PIXI.Sprite,
      Text = PIXI.Text,
      TextStyle = PIXI.TextStyle;

  //Create app
  let app = new Application(
    {
      width: 2102, 
      height: 796,                       
      antialiasing: true, 
      transparent: false, 
      resolution: 1
    }
  );

  //Add the canvas
  document.body.appendChild(app.view);
  loader
    .add("images/bi-paint-textures.json").load(setup);

  let state, rafPlane, redBaron, plane, balloon, gameScene, gameOverScene, id, sky, largeCloud1, largeCloud2, flatCloud, flatCloudDistant, hills, nearHill, hut, rafPaintBall, redBaronPaintBall, keyState, p1, p2;
  
  function setup() {
    gameScene = new Container();
    app.stage.addChild(gameScene);
    id = resources["images/bi-paint-textures.json"].textures;
  
    // set up assets
    sky = new Sprite(id["Backgrd.png"]);
    gameScene.addChild(sky);

    balloon = new Sprite(id["Balloon.png"]);
    balloon.x = 850;
    balloon.y = 550;
  
    largeCloud1 = new Sprite(id["BIGCloud.png"]);
    largeCloud1.x = 600;
    largeCloud1.y = 220;
  
    largeCloud2 = new Sprite(id["BIGCloud.png"]);
    largeCloud2.x = 260;
    largeCloud2.y = 180;
  
    hills = new Sprite(id["Hills.png"]);
    hills.y = 796 - hills.height;
  
    nearHill = new Sprite(id["Front_Hill.png"]);
    nearHill.y = sky.height - nearHill.height;
  
    hut = new Sprite(id["House.png"]);
    hut.x = sky.width/2 - hut.width/2;
    hut.y = sky.height - hut.height;

    // Animate planes
    plane = function plane(planeSprite, x) {
      planeSprite.x = x;
      planeSprite.y = sky.height - planeSprite.height/2;
      planeSprite.rotation = 0;
      planeSprite.speed = 0;
      planeSprite.pivot._x = 40;
      planeSprite.pivot._y = 28;
      planeSprite.takeOff = false;
      planeSprite.stall = false;
      return null;
    }

    // set up rafPlane
    rafPlane = new Sprite(id["RAF_Plane02sized.png"]);
    plane(rafPlane, 40);

    // red Baron
    redBaron = new Sprite(id["RedBarren flipped.png"]);
    plane(redBaron, sky.width - redBaron.width + 40);
    
    // set up key logging
    keyState = [];
  
    flatCloud = new Sprite(id["FlatCloud.png"]);
    flatCloud.x = 160;
    flatCloud.y = 600;
  
    flatCloudDistant = new Sprite(id["FlatCloud_distant.png"]);
    flatCloudDistant.x = 800;
    flatCloudDistant.y = 580;

    // players
    p1 = {};
    p2 = {};
  
    gameScene.addChild(flatCloudDistant, hills, flatCloud, nearHill, balloon, hut, rafPlane, redBaron, largeCloud1, largeCloud2);

    //Set the game state
    state = play;
  
    //Start the game loop 
    app.ticker.add(delta => gameLoop(delta));
  }
  
  function gameLoop(delta) {
    state(delta);
  }
  
  function play() {
    // boundary
    if (rafPlane.x > sky.width - 40) rafPlane.x = 0;
    if (rafPlane.x < 0) rafPlane.x = sky.width - 40;
    if (rafPlane.y < 28) {
      rafPlane.y = 28; 
      rafPlane.stall = true;
    }
    if (redBaron.x > sky.width - 40) redBaron.x = 0;
    if (redBaron.x < 0) redBaron.x = sky.width - 40;
    if (redBaron.y < 28) {
      redBaron.y = 28; 
      redBaron.stall = true;
    }

    // func to swap in crashed plane sprite
    const crash = function crash(planeSprite, crashedPlane) {
      crashedPlane.x = planeSprite.x;
      crashedPlane.y = planeSprite.y;
      crashedPlane.pivot._x = planeSprite.pivot._x;
      crashedPlane.pivot._y = planeSprite.pivot._y;
      crashedPlane.rotation = planeSprite.rotation;
      gameScene.addChild(crashedPlane);
      gameScene.removeChild(planeSprite);
      setTimeout(() => {gameScene.removeChild(crashedPlane)}, 1000);
    }

    // rafPlane collision logic
    let rafGrCol = false, hutWallCol = false, hutRoofCol = false, airCol = false;
    // ground col
    if (rafPlane.takeOff && rafPlane.y > sky.height - 28) rafGrCol = true;

    // hut wall col, 2x rectangles
    if (
      !(hut.x + hut.width < rafPlane.x + 20) &&
      !(rafPlane.x + rafPlane.width < hut.x + 50) &&
      !(hut.y + hut.height < rafPlane.y) &&
      !(rafPlane.y + rafPlane.height < hut.y + 88)
    ) hutWallCol = true;

    // hut roof col, 2x circles
    hutRoofCol = (() => {
      let dX = hut.x + 75 - rafPlane.x, dY = hut.y + 70 - rafPlane.y;
      let distance = Math.sqrt( (dX * dX ) + (dY * dY ) );
      return distance < ( ((hut.width - 20) / 2) + (rafPlane.height / 2 ) );
    })();

    // rafPlane ground or hut collision occurred
    if (rafGrCol || hutWallCol || hutRoofCol) {
      p2.score += 1;
      crashedPlane = new Sprite(id["crashedRAF.png"]);
      crash(rafPlane, crashedPlane);
      rafPlane = new Sprite(id["RAF_Plane02sized.png"]);
      plane(rafPlane, 40);
      gameScene.addChild(rafPlane);
    }
    
    // redBaron collision logic
    let RBGrCol = false, RBhutWallCol = false, RBhutRoofCol = false;
    // ground col
    if (redBaron.takeOff && redBaron.y > sky.height - 28) RBGrCol = true;

    // hut wall col, 2x rectangles
    if (
      !(hut.x + hut.width < redBaron.x + 20) &&
      !(redBaron.x + redBaron.width < hut.x + 50) &&
      !(hut.y + hut.height < redBaron.y) &&
      !(redBaron.y + redBaron.height < hut.y + 88)
    ) RBhutWallCol = true;

    // hut roof col, 2x circles
    RBhutRoofCol = (() => {
      let dX = hut.x + 75 - redBaron.x, dY = hut.y + 70 - redBaron.y;
      let distance = Math.sqrt( (dX * dX ) + (dY * dY ) );
      return distance < ( ((hut.width - 20) / 2) + (redBaron.height / 2 ) );
    })();

    // redBaron ground or hut collision occured
    if (RBGrCol || RBhutWallCol || RBhutRoofCol) {
      p1.score += 1;
      crashedPlane = new Sprite(id["crashedRB.png"]);
      crash(redBaron, crashedPlane);
      redBaron = new Sprite(id["RedBarren flipped.png"]);
      plane(redBaron, sky.width - redBaron.width + 40);
      gameScene.addChild(redBaron);
    }

    // left and right controls
    if (rafPlane.takeOff) {
      //z key
      if(keyState[90]) {
        rafPlane.rotation -= 1/8;
        if (rafPlane.rotation < (-2 * Math.PI)) {
          rafPlane.rotation = 0;
        }
      }
      //x key
      if(keyState[88]) {
        rafPlane.rotation += 1/8;
        if (rafPlane.rotation > 2 * Math.PI) {
          rafPlane.rotation = 0;
        }
      }
    }

    if (redBaron.takeOff) {
      //Left arrow key
      if(keyState[37]) {
        redBaron.rotation -= 1/8;
        if (redBaron.rotation < (-2 * Math.PI)) {
          redBaron.rotation = 0;
        }
      };
      // right arrow
      if(keyState[39]) {
        redBaron.rotation += 1/8;
        if (redBaron.rotation > 2 * Math.PI) {
          redBaron.rotation = 0;
        }
      }
    }

    // rafPlane regular flight
    if (!rafPlane.stall) {
      // gravity
      // plane flying up
       if ( (rafPlane.rotation < 0 && rafPlane.rotation > -Math.PI)  || (rafPlane.rotation > Math.PI && rafPlane.rotation < 2 * Math.PI) ) {
      rafPlane.speed -= 0.25 * Math.abs(Math.sin(rafPlane.rotation));
      }
      // plane flying down
      if (rafPlane.speed < 10 && ((-Math.PI > rafPlane.rotation && rafPlane.rotation > -2 * Math.PI) || (rafPlane.rotation > 0 && rafPlane.rotation < Math.PI))) {
        rafPlane.speed += 0.25 * Math.abs(Math.sin(rafPlane.rotation));
      }

      // wind resistance
      if (rafPlane.speed > 2) {
        rafPlane.speed -= 0.02;
      }

      rafPlane.vx = rafPlane.speed * Math.cos(rafPlane.rotation);
      rafPlane.vy = rafPlane.speed * Math.sin(rafPlane.rotation);

      rafPlane.x += rafPlane.vx;
      rafPlane.y += rafPlane.vy;

      // plane able to take off begin mechanics
      if (rafPlane.speed > 5) {
        rafPlane.takeOff = true;
      }

      // slow plane loss of uplift
      if (rafPlane.takeOff && rafPlane.speed < 5) {
        rafPlane.y += 1;
      }

      // accelerate, q
      if(keyState[65]) {
        if (rafPlane.speed < 6) {
          rafPlane.speed += 0.16;
        }
      }

      if (rafPlane.takeOff && rafPlane.speed < 3) {
        rafPlane.stall = true;
        keyState[65] = false;
      }
    }

    // rafPlane if stalled
    if (rafPlane.takeOff && rafPlane.stall) {
      // if stalling facing left continue fall left
      if ((rafPlane.rotation < -0.5 * Math.PI && rafPlane.rotation > -1.5 * Math.PI) || (rafPlane.rotation > 0.5 * Math.PI && rafPlane.rotation < 1.5 * Math.PI)) {
        rafPlane.x -= 1;
      }
      // if stalling facing right, fall right
      if ((rafPlane.rotation > -0.5 * Math.PI && rafPlane.rotation < 0) || (rafPlane.rotation > 1.5 * Math.PI && rafPlane.rotation < 2 * Math.PI)) {
        rafPlane.x += 1;
      }
      // gravity
      rafPlane.y *= 1.0125;

      // if facing downward no stall
      if ((rafPlane.rotation < -1.4 * Math.PI && rafPlane.rotation > -1.6 * Math.PI) || (rafPlane.rotation > 0.4 * Math.PI && rafPlane.rotation < 0.6 * Math.PI)) {
        rafPlane.speed = 4;
        rafPlane.stall = false;
        keyState[65] = true;
      }
    }

    // redBaron regular flight
    if (!redBaron.stall) {
      // gravity
      // plane flying up
      if ( (redBaron.rotation > 0 && redBaron.rotation < Math.PI)  || (redBaron.rotation < -Math.PI && redBaron.rotation > -2 * Math.PI) ) {
      redBaron.speed -= 0.25 * Math.abs(Math.sin(redBaron.rotation));
      }
      // plane flying down
      if (redBaron.speed < 10 && ((redBaron.rotation < 0 && redBaron.rotation > -Math.PI)  || (redBaron.rotation > Math.PI && redBaron.rotation < 2 * Math.PI))) {
        redBaron.speed += 0.25 * Math.abs(Math.sin(redBaron.rotation));
      }

      // wind resistance
      if (redBaron.speed > 2) {
        redBaron.speed -= 0.02;
      }

      redBaron.vx = redBaron.speed * Math.cos(redBaron.rotation);
      redBaron.vy = redBaron.speed * Math.sin(redBaron.rotation);

      redBaron.x -= redBaron.vx;
      redBaron.y -= redBaron.vy;

      // plane able to take off begin mechanics
      if (redBaron.speed > 5) {
        redBaron.takeOff = true;
      }

      // slow plane loss of uplift
      if (redBaron.takeOff && redBaron.speed < 5) {
        redBaron.y += 1;
      }

      // accelerate, up arrow
      if(keyState[38]) {
        if (redBaron.speed < 6) {
          redBaron.speed += 0.16;
        }
      }

      if (redBaron.takeOff && redBaron.speed < 3) {
        redBaron.stall = true;
        keyState[38] = false;
      }
    }

    // redBaron if stalled
    if (redBaron.takeOff && redBaron.stall) {
      // if stalling facing left continue fall left
      if ((redBaron.rotation < 0.5 * Math.PI && redBaron.rotation > -0.5 * Math.PI) || (redBaron.rotation > 1.5 * Math.PI && redBaron.rotation < -1.5 * Math.PI)) {
        redBaron.x -= 1;
      }
      // if stalling facing right, fall right
      if ((redBaron.rotation > 0.5 * Math.PI && redBaron.rotation < 1.5 * Math.PI) || (redBaron.rotation < -0.5 * Math.PI && redBaron.rotation < -1.5 * Math.PI)) {
        redBaron.x += 1;
      }
      // gravity
      redBaron.y *= 1.0125;

      // if facing downward no stall
      if ((redBaron.rotation < -0.4 * Math.PI && redBaron.rotation > -0.6 * Math.PI) || (redBaron.rotation > 1.4 * Math.PI && redBaron.rotation < 1.6 * Math.PI)) {
        redBaron.speed = 4;
        redBaron.stall = false;
        keyState[38] = true;
      }
    }
  }
  
  /* Helper functions */
  // key log funcs
  const keyPress = function(e) {
    if (e.keyCode === 38 || e.keyCode === 37 || e.keyCode === 39 || e.keyCode === 32 || e.keyCode === 65 || e.keyCode === 88 || e.keyCode === 90) {
      keyState[e.keyCode] = true;
      event.preventDefault();
    }
  }

  const keyRelease = function(e) {
    if (e.keyCode === 38 || e.keyCode === 37 || e.keyCode === 39 || e.keyCode === 32 || e.keyCode === 65 || e.keyCode === 88 || e.keyCode === 90) {
      keyState[e.keyCode] = false;
      event.preventDefault();
    }
  }

  window.addEventListener("keydown", keyPress);
  window.addEventListener("keyup", keyRelease);

  </script>
</script>
</body>
</html>